name: Workflow Failure Analyzer

# Trigger this workflow when other workflows complete
on:
  workflow_run:
    workflows: [
      "Automated Ansible Lint Fixes with Aider",
      "Dependency Testing Pipeline", 
      "ADR Compliance and File Structure Validation",
      "Ansible Version Auto-Update",
      "Release and Deploy collection"
    ]
    types: [completed]
  
  # Allow manual triggering for testing
  workflow_dispatch:
    inputs:
      analyze_all_recent:
        description: 'Analyze all recent workflows (not just current run)'
        required: false
        default: 'false'
        type: boolean
      max_workflows:
        description: 'Maximum number of workflows to analyze'
        required: false
        default: '10'
        type: string

# Ensure only one analysis runs at a time
concurrency:
  group: workflow-failure-analyzer
  cancel-in-progress: false

permissions:
  contents: read
  issues: write
  actions: read
  pull-requests: read

env:
  PYTHON_VERSION: "3.11"

jobs:
  analyze-workflow-failures:
    runs-on: self-hosted
    timeout-minutes: 30
    
    # Only run if there were failures or manual trigger
    if: >
      github.event_name == 'workflow_dispatch' || 
      github.event.workflow_run.conclusion == 'failure' ||
      github.event.workflow_run.conclusion == 'cancelled'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      
      - name: Set up Python 3.11 for self-hosted runner
        run: |
          echo "üêç Setting up Python 3.11 for self-hosted runner..."

          # Check if Python 3.11 is already available
          if command -v python3.11 >/dev/null 2>&1; then
            echo "‚úÖ Python 3.11 already available: $(python3.11 --version)"
            PYTHON_CMD="python3.11"
          elif command -v python3 >/dev/null 2>&1; then
            PYTHON_VERSION=$(python3 --version 2>&1 | cut -d' ' -f2)
            echo "‚úÖ Found python3: $PYTHON_VERSION"

            # Check if it's 3.11+
            if python3 -c "import sys; exit(0 if sys.version_info >= (3, 11) else 1)" 2>/dev/null; then
              echo "‚úÖ Python3 version is 3.11+, using python3"
              PYTHON_CMD="python3"
            else
              echo "‚ö†Ô∏è Python3 version is < 3.11, attempting to install Python 3.11..."

              # Install Python 3.11 on RHEL/Rocky systems
              if command -v yum >/dev/null 2>&1; then
                sudo yum install -y python3.11 python3.11-pip python3.11-devel || {
                  echo "‚ùå Failed to install Python 3.11 via yum"
                  echo "Using available Python3: $PYTHON_VERSION"
                  PYTHON_CMD="python3"
                }

                # Check if installation succeeded
                if command -v python3.11 >/dev/null 2>&1; then
                  echo "‚úÖ Python 3.11 installed successfully"
                  PYTHON_CMD="python3.11"
                else
                  echo "‚ö†Ô∏è Python 3.11 installation failed, using python3"
                  PYTHON_CMD="python3"
                fi
              else
                echo "‚ö†Ô∏è Non-RHEL system, using available python3"
                PYTHON_CMD="python3"
              fi
            fi
          else
            echo "‚ùå No Python installation found, attempting basic installation..."
            if command -v yum >/dev/null 2>&1; then
              sudo yum install -y python3.11 python3.11-pip || sudo yum install -y python3 python3-pip
            fi

            # Final check
            if command -v python3.11 >/dev/null 2>&1; then
              PYTHON_CMD="python3.11"
            elif command -v python3 >/dev/null 2>&1; then
              PYTHON_CMD="python3"
            else
              echo "‚ùå Failed to install Python"
              exit 1
            fi
          fi

          echo "PYTHON_CMD=$PYTHON_CMD" >> $GITHUB_ENV
          echo "üéØ Using Python command: $PYTHON_CMD"
          $PYTHON_CMD --version

      - name: Install Python dependencies
        run: |
          echo "üì¶ Installing Python dependencies with $PYTHON_CMD..."

          # Upgrade pip first
          $PYTHON_CMD -m pip install --upgrade pip --user

          # Install required packages for the analyzer
          $PYTHON_CMD -m pip install --user \
            requests \
            urllib3 \
            pyyaml \
            packaging

          # Verify installations
          echo "‚úÖ Installed packages:"
          $PYTHON_CMD -m pip list --user | grep -E "(requests|urllib3|PyYAML|packaging)"
      
      - name: Load environment variables
        run: |
          if [ -f .env ]; then
            echo "Loading environment variables from .env"
            export $(cat .env | grep -v '^#' | xargs)
            echo "RED_HAT_MAAS_API_KEY=${RED_HAT_MAAS_API_KEY}" >> $GITHUB_ENV
          else
            echo "Warning: .env file not found"
          fi
      
      - name: Validate environment
        run: |
          echo "Validating required environment variables..."
          
          # Check Python installation
          echo "Python command: $PYTHON_CMD"
          $PYTHON_CMD --version

          # Check GitHub token
          if [ -z "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "‚ùå GITHUB_TOKEN is not available"
            exit 1
          fi

          # Check Red Hat MaaS API key
          if [ -z "$RED_HAT_MAAS_API_KEY" ]; then
            echo "‚ùå RED_HAT_MAAS_API_KEY is not available"
            exit 1
          fi
          
          echo "‚úÖ All required environment variables are available"
          echo "‚úÖ Repository: ${{ github.repository }}"
          echo "‚úÖ Triggering workflow: ${{ github.event.workflow_run.name || 'Manual trigger' }}"
      
      - name: Run workflow failure analysis
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_WORKFLOW_RUN_URL: ${{ github.event.workflow_run.html_url || github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          RED_HAT_MAAS_API_KEY: ${{ env.RED_HAT_MAAS_API_KEY }}
          TRIGGERING_WORKFLOW_ID: ${{ github.event.workflow_run.id || 'manual' }}
          TRIGGERING_WORKFLOW_NAME: ${{ github.event.workflow_run.name || 'Manual Analysis' }}
          ANALYZE_ALL_RECENT: ${{ github.event.inputs.analyze_all_recent || 'false' }}
          MAX_WORKFLOWS: ${{ github.event.inputs.max_workflows || '10' }}
        run: |
          echo "üîç Starting workflow failure analysis..."
          echo "Triggering workflow: $TRIGGERING_WORKFLOW_NAME"
          echo "Analysis mode: $([ "$ANALYZE_ALL_RECENT" = "true" ] && echo "All recent workflows" || echo "Triggered workflow only")"
          
          # Make the script executable
          chmod +x scripts/workflow-failure-analyzer.py

          # Run the analysis
          $PYTHON_CMD scripts/workflow-failure-analyzer.py
      
      - name: Upload analysis artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: workflow-failure-analysis-${{ github.run_id }}
          path: |
            workflow-failure-analysis-report.md
            *.log
          retention-days: 30
      
      - name: Comment on triggering workflow (if applicable)
        if: github.event.workflow_run.id && success()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create a comment on the original workflow run if it failed
          if [ "${{ github.event.workflow_run.conclusion }}" = "failure" ]; then
            echo "Creating analysis comment for failed workflow..."
            
            # This would require additional API calls to comment on the original run
            # For now, we'll just log the information
            echo "‚úÖ Analysis completed for workflow: ${{ github.event.workflow_run.name }}"
            echo "üìã Check the Issues tab for detailed failure analysis"
            echo "üîó Analysis run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          fi
      
      - name: Summary
        if: always()
        run: |
          echo "## Workflow Failure Analysis Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f workflow-failure-analysis-report.md ]; then
            echo "### Analysis Report" >> $GITHUB_STEP_SUMMARY
            cat workflow-failure-analysis-report.md >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è Analysis report not generated" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Links" >> $GITHUB_STEP_SUMMARY
          echo "- üîó [View Issues](https://github.com/${{ github.repository }}/issues?q=is%3Aissue+is%3Aopen+label%3Aworkflow-failure)" >> $GITHUB_STEP_SUMMARY
          echo "- üìä [Workflow Runs](https://github.com/${{ github.repository }}/actions)" >> $GITHUB_STEP_SUMMARY
          echo "- üìã [Analysis Artifacts](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY

  # Optional: Create a summary issue if multiple workflows are failing
  create-summary-issue:
    runs-on: self-hosted
    needs: analyze-workflow-failures
    if: always() && needs.analyze-workflow-failures.result == 'success'
    
    permissions:
      issues: write
      contents: read
    
    steps:
      - name: Check for multiple recent failures
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Checking for patterns in recent workflow failures..."
          
          # This could be enhanced to detect patterns and create summary issues
          # For now, we'll just log the check
          echo "‚úÖ Summary analysis completed"
          echo "Individual issues have been created for specific failures"
