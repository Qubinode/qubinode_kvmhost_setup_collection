name: Workflow Failure Analyzer

# Trigger this workflow when other workflows complete
on:
  workflow_run:
    workflows: [
      "Automated Ansible Lint Fixes with Aider",
      "Dependency Testing Pipeline", 
      "ADR Compliance and File Structure Validation",
      "Ansible Version Auto-Update",
      "Release and Deploy collection"
    ]
    types: [completed]
  
  # Allow manual triggering for testing
  workflow_dispatch:
    inputs:
      analyze_all_recent:
        description: 'Analyze all recent workflows (not just current run)'
        required: false
        default: 'false'
        type: boolean
      max_workflows:
        description: 'Maximum number of workflows to analyze'
        required: false
        default: '10'
        type: string

# Ensure only one analysis runs at a time
concurrency:
  group: workflow-failure-analyzer
  cancel-in-progress: false

permissions:
  contents: read
  issues: write
  actions: read
  pull-requests: read

env:
  PYTHON_VERSION: "3.11"

jobs:
  analyze-workflow-failures:
    runs-on: self-hosted
    timeout-minutes: 30
    
    # Only run if there were failures or manual trigger
    if: >
      github.event_name == 'workflow_dispatch' || 
      github.event.workflow_run.conclusion == 'failure' ||
      github.event.workflow_run.conclusion == 'cancelled'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 1
      
      - name: Set up Python 3.11 for self-hosted runner
        run: |
          echo "üêç Setting up Python 3.11 for self-hosted runner..."

          # Check if Python 3.11 is already available
          if command -v python3.11 >/dev/null 2>&1; then
            echo "‚úÖ Python 3.11 already available: $(python3.11 --version)"
            PYTHON_CMD="python3.11"
          elif command -v python3 >/dev/null 2>&1; then
            PYTHON_VERSION=$(python3 --version 2>&1 | cut -d' ' -f2)
            echo "‚úÖ Found python3: $PYTHON_VERSION"

            # Check if it's 3.11+
            if python3 -c "import sys; exit(0 if sys.version_info >= (3, 11) else 1)" 2>/dev/null; then
              echo "‚úÖ Python3 version is 3.11+, using python3"
              PYTHON_CMD="python3"
            else
              echo "‚ö†Ô∏è Python3 version is < 3.11, attempting to install Python 3.11..."

              # Install Python 3.11 on RHEL/Rocky systems
              if command -v yum >/dev/null 2>&1; then
                # Detect OS and use appropriate package manager
                if [ -f /etc/os-release ]; then
                  . /etc/os-release
                  echo "Detected OS: $NAME ($ID)"
                fi

                # Determine package manager
                if command -v dnf &> /dev/null; then
                  PKG_MGR="dnf"
                elif command -v yum &> /dev/null; then
                  PKG_MGR="yum"
                else
                  echo "Error: No suitable package manager found"
                  PKG_MGR="yum"  # fallback
                fi
                echo "Using package manager: $PKG_MGR"

                # Skip EPEL configuration to avoid GPG verification failures
                if [[ "$ID" == "rocky" ]] || [[ "$ID" == "almalinux" ]]; then
                  echo "Skipping EPEL configuration for Rocky/Alma Linux to avoid GPG issues"
                  # Clean any existing EPEL metadata that might cause issues
                  sudo rm -rf /var/cache/dnf/epel* /var/cache/yum/epel* 2>/dev/null || true
                  # Remove any existing EPEL repositories to prevent conflicts
                  sudo $PKG_MGR remove -y epel-release 2>/dev/null || true
                  echo "EPEL cleanup completed"
                fi

                # Install Python with appropriate flags
                if [[ "$ID" == "rocky" ]]; then
                  echo "Using --nogpgcheck for Rocky Linux package installation"
                  sudo $PKG_MGR install -y --nogpgcheck python3.11 python3.11-pip python3.11-devel || {
                    echo "‚ùå Failed to install Python 3.11 via $PKG_MGR"
                    echo "Using available Python3: $PYTHON_VERSION"
                    PYTHON_CMD="python3"
                  }
                else
                  sudo $PKG_MGR install -y python3.11 python3.11-pip python3.11-devel || {
                    echo "‚ùå Failed to install Python 3.11 via $PKG_MGR"
                    echo "Using available Python3: $PYTHON_VERSION"
                    PYTHON_CMD="python3"
                  }
                fi

                # Check if installation succeeded
                if command -v python3.11 >/dev/null 2>&1; then
                  echo "‚úÖ Python 3.11 installed successfully"
                  PYTHON_CMD="python3.11"
                else
                  echo "‚ö†Ô∏è Python 3.11 installation failed, using python3"
                  PYTHON_CMD="python3"
                fi
              else
                echo "‚ö†Ô∏è Non-RHEL system, using available python3"
                PYTHON_CMD="python3"
              fi
            fi
          else
            echo "‚ùå No Python installation found, attempting basic installation..."
            if command -v yum >/dev/null 2>&1; then
              # Detect OS and use appropriate package manager
              if [ -f /etc/os-release ]; then
                . /etc/os-release
                echo "Detected OS: $NAME ($ID)"
              fi

              # Determine package manager
              if command -v dnf &> /dev/null; then
                PKG_MGR="dnf"
              elif command -v yum &> /dev/null; then
                PKG_MGR="yum"
              else
                PKG_MGR="yum"  # fallback
              fi

              # Skip EPEL configuration to avoid GPG verification failures
              if [[ "$ID" == "rocky" ]] || [[ "$ID" == "almalinux" ]]; then
                echo "Skipping EPEL configuration for Rocky/Alma Linux to avoid GPG issues"
                # Clean any existing EPEL metadata that might cause issues
                sudo rm -rf /var/cache/dnf/epel* /var/cache/yum/epel* 2>/dev/null || true
                # Remove any existing EPEL repositories to prevent conflicts
                sudo $PKG_MGR remove -y epel-release 2>/dev/null || true
                echo "EPEL cleanup completed"
              fi

              # Install Python with appropriate flags
              if [[ "$ID" == "rocky" ]]; then
                echo "Using --nogpgcheck for Rocky Linux package installation"
                sudo $PKG_MGR install -y --nogpgcheck python3.11 python3.11-pip || sudo $PKG_MGR install -y --nogpgcheck python3 python3-pip
              else
                sudo $PKG_MGR install -y python3.11 python3.11-pip || sudo $PKG_MGR install -y python3 python3-pip
              fi
            fi

            # Final check
            if command -v python3.11 >/dev/null 2>&1; then
              PYTHON_CMD="python3.11"
            elif command -v python3 >/dev/null 2>&1; then
              PYTHON_CMD="python3"
            else
              echo "‚ùå Failed to install Python"
              exit 1
            fi
          fi

          echo "PYTHON_CMD=$PYTHON_CMD" >> $GITHUB_ENV
          echo "üéØ Using Python command: $PYTHON_CMD"
          $PYTHON_CMD --version

      - name: Create virtual environment and install dependencies
        run: |
          echo "üß∞ Creating dedicated virtual environment with $PYTHON_CMD..."

          # Create venv in workspace
          $PYTHON_CMD -m venv .venv

          # Use absolute path for Python inside venv across steps
          VENV_PY="$PWD/.venv/bin/python"
          VENV_PIP="$PWD/.venv/bin/pip"
          echo "PYTHON_CMD=$VENV_PY" >> $GITHUB_ENV

          # Upgrade pip and install required packages into venv
          $VENV_PY -m pip install --upgrade pip
          $VENV_PIP install \
            requests \
            urllib3 \
            pyyaml \
            packaging

          # Verify installations
          echo "‚úÖ Installed packages in venv:"
          $VENV_PIP list | grep -E "(requests|urllib3|PyYAML|packaging)" || true
      
      - name: Load environment variables
        run: |
          if [ -f .env ]; then
            echo "Loading environment variables from .env"
            export $(cat .env | grep -v '^#' | xargs)
            # Export to GitHub env so subsequent steps see it
            if [ -n "$RED_HAT_MAAS_API_KEY" ]; then
              echo "RED_HAT_MAAS_API_KEY=[masked] (from .env)"
              echo "RED_HAT_MAAS_API_KEY=$RED_HAT_MAAS_API_KEY" >> $GITHUB_ENV
            fi
          else
            echo "Warning: .env file not found"
          fi

          # Fallback to GitHub Secret if env var not set by .env
          if [ -z "$RED_HAT_MAAS_API_KEY" ] && [ -n "${{ secrets.RED_HAT_MAAS_API_KEY }}" ]; then
            echo "Using RED_HAT_MAAS_API_KEY from GitHub Secrets"
            echo "RED_HAT_MAAS_API_KEY=${{ secrets.RED_HAT_MAAS_API_KEY }}" >> $GITHUB_ENV
          fi
      
      - name: Validate environment
        run: |
          echo "üîç Validating environment and dependencies..."

          # Check Python installation and environment
          echo "Python command: $PYTHON_CMD"
          echo "Python version: $($PYTHON_CMD --version)"
          echo "Python executable path: $(which $PYTHON_CMD)"

          # Display venv being used
          echo "Using Python: $PYTHON_CMD"
          ls -l "$PYTHON_CMD" || true
          "$PYTHON_CMD" -c "import sys; print('sys.prefix:', sys.prefix); print('sys.executable:', sys.executable)"

          # Test Python imports
          echo "üß™ Testing Python package imports..."
          $PYTHON_CMD -c "import requests; print(f'‚úÖ requests: {requests.__version__}')" || echo "‚ùå requests import failed"
          $PYTHON_CMD -c "import urllib3; print(f'‚úÖ urllib3: {urllib3.__version__}')" || echo "‚ùå urllib3 import failed"
          $PYTHON_CMD -c "import yaml; print('‚úÖ PyYAML imported successfully')" || echo "‚ùå PyYAML import failed"
          $PYTHON_CMD -c "import json; print('‚úÖ json (built-in) available')" || echo "‚ùå json import failed"

          # Check GitHub token
          if [ -z "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "‚ùå GITHUB_TOKEN is not available"
            exit 1
          fi

          # Check Red Hat MaaS API key
          if [ -z "$RED_HAT_MAAS_API_KEY" ]; then
            echo "‚ùå RED_HAT_MAAS_API_KEY is not available"
            exit 1
          fi

          echo "‚úÖ All required environment variables are available"
          echo "‚úÖ Repository: ${{ github.repository }}"
          echo "‚úÖ Triggering workflow: ${{ github.event.workflow_run.name || 'Manual trigger' }}"
      
      - name: Run workflow failure analysis
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_WORKFLOW_RUN_URL: ${{ github.event.workflow_run.html_url || github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          RED_HAT_MAAS_API_KEY: ${{ env.RED_HAT_MAAS_API_KEY }}
          TRIGGERING_WORKFLOW_ID: ${{ github.event.workflow_run.id || 'manual' }}
          TRIGGERING_WORKFLOW_NAME: ${{ github.event.workflow_run.name || 'Manual Analysis' }}
          ANALYZE_ALL_RECENT: ${{ github.event.inputs.analyze_all_recent || 'false' }}
          MAX_WORKFLOWS: ${{ github.event.inputs.max_workflows || '10' }}
        run: |
          echo "üîç Starting workflow failure analysis..."
          echo "Triggering workflow: $TRIGGERING_WORKFLOW_NAME"
          echo "Analysis mode: $([ "$ANALYZE_ALL_RECENT" = "true" ] && echo "All recent workflows" || echo "Triggered workflow only")"
          
          # Make the script executable
          chmod +x scripts/workflow-failure-analyzer.py

          # Run the analysis using venv python
          $PYTHON_CMD scripts/workflow-failure-analyzer.py
      
      - name: Upload analysis artifacts
        uses: actions/upload-artifact@v5
        if: always()
        with:
          name: workflow-failure-analysis-${{ github.run_id }}
          path: |
            workflow-failure-analysis-report.md
            *.log
          retention-days: 30
      
      - name: Comment on triggering workflow (if applicable)
        if: github.event.workflow_run.id && success()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create a comment on the original workflow run if it failed
          if [ "${{ github.event.workflow_run.conclusion }}" = "failure" ]; then
            echo "Creating analysis comment for failed workflow..."
            
            # This would require additional API calls to comment on the original run
            # For now, we'll just log the information
            echo "‚úÖ Analysis completed for workflow: ${{ github.event.workflow_run.name }}"
            echo "üìã Check the Issues tab for detailed failure analysis"
            echo "üîó Analysis run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          fi
      
      - name: Summary
        if: always()
        run: |
          echo "## Workflow Failure Analysis Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f workflow-failure-analysis-report.md ]; then
            echo "### Analysis Report" >> $GITHUB_STEP_SUMMARY
            cat workflow-failure-analysis-report.md >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è Analysis report not generated" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Links" >> $GITHUB_STEP_SUMMARY
          echo "- üîó [View Issues](https://github.com/${{ github.repository }}/issues?q=is%3Aissue+is%3Aopen+label%3Aworkflow-failure)" >> $GITHUB_STEP_SUMMARY
          echo "- üìä [Workflow Runs](https://github.com/${{ github.repository }}/actions)" >> $GITHUB_STEP_SUMMARY
          echo "- üìã [Analysis Artifacts](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY

  # Optional: Create a summary issue if multiple workflows are failing
  create-summary-issue:
    runs-on: self-hosted
    needs: analyze-workflow-failures
    if: always() && needs.analyze-workflow-failures.result == 'success'
    
    permissions:
      issues: write
      contents: read
    
    steps:
      - name: Check for multiple recent failures
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Checking for patterns in recent workflow failures..."
          
          # This could be enhanced to detect patterns and create summary issues
          # For now, we'll just log the check
          echo "‚úÖ Summary analysis completed"
          echo "Individual issues have been created for specific failures"
